<script src="../dist/browser/tfjs-onnx.js"></script>
<script src="ILSVRC2012.js"></script>

<canvas id="img"></canvas>
<div id="result"></div>

<script>
  const imgUrl = 'img/cat.jpg';
  const modelUrl = 'models/squeezenet/model.onnx';

  (async function(){
    // Load the image
    const imgElem = document.getElementById('img');
    const img = await tf.onnx.util.loadImageData(imgUrl);

    // Load the model
    const model = await tf.onnx.loadModel(modelUrl);
    console.debug(model);

    // Load the pixel and scale to model input
    const data = loadImageData(img, [224, 224]);

    // Visualize image
    displayImage(data, 'img');

    // Perform the forward pass
    // and return the prediction
    const predictions = tf.tidy(() => model.predict(data));

    // Output the result
    const topK = await getTopKClasses(predictions, 5);

    const probs = topK[0];
    const classNames = Array.from(topK[1]).map(d => IMAGENET_CLASSES[d]);

    displayLabel(probs, classNames, 'result');
  })();

  function loadImageData(img, shape) {
    const pixels = tf.fromPixels(img);
    const data = tf.image.resizeBilinear(pixels, shape);
    return data.expandDims().cast('float32');
  }

  function displayImage(data, elemId) {
    const elem = document.getElementById(elemId);
    const pixels = tf.squeeze(data).div(tf.scalar(255));
    tf.toPixels(pixels, elem);
  }

  function displayLabel(probs, labels, elemId) {
    const elem = document.getElementById(elemId);
    const f = n => n.toLocaleString(undefined, { minimumFractionDigits: 2 });

    const row = labels.map((d,i) => {
      return labels[i] + ": " + f(probs[i] * 100) + "%";
    })

    elem.innerHTML = row.join("<br>");
  }

  async function getTopKClasses(logits, topK) {

    const values = await logits.data();

    const valuesAndIndices = [];
    for (let i = 0; i < values.length; i++) {
      valuesAndIndices.push({value: values[i], index: i});
    }
    valuesAndIndices.sort((a, b) => {
      return b.value - a.value;
    });
    const topkValues = new Float32Array(topK);
    const topkIndices = new Int32Array(topK);

    for (let i = 0; i < topK; i++) {
      topkValues[i] = valuesAndIndices[i].value;
      topkIndices[i] = valuesAndIndices[i].index;
    }

    return [topkValues, topkIndices];
  }
</script>
